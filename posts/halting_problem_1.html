<h3>Building an Intuition for the Halting Problem</h3>

<p>Posted on 3/25/2021 10:22:55 AM</p>

<p>undecidability</p>

<section>That halting problem is very well known in the field of computer science; it states that no computer program can exist that can determine whether or not any program will terminate. Here we will be using some informal definitions and some simple Python code to demonstrate the undecidability of the halting problem.</section>

<section><b>Decidability</b> - A <b>Turing machine</b> is decidable if every input to the Turing machine yields one of two possible outputs.</section>

<section>Just as the Turing machine can halt, it can also fail to halt. Failing to halt does not necessarily mean the program has entered into an infinite loop; some program and input combinations just take an incredibly long time to execute (e.g. brute forcing a 256-bit key). The logic of most programs can be determined pretty easily, take this Python code for example:</section>

<code>
<p>def terminate():</p>
<p class="indent-1">print('Terminating...')</p>
<br/>
<p>terminate()</p>
</code>

<section>This code clearly prints a message and finishes execution, halting the program. This is distinct from sections of code that loop indefinitely due to some design flaw:</section>

<code>
<p>def loop():</p>
<p class="indent-1">while True: continue</p>
<br/>
<p>loop()</p>
</code>

<section>This code will clearly never terminate on its own, and therefore does not halt. It seems easy enough to determine whether a simple piece of code will halt or not. If the halting problem was decidable, we would be able to do this for any arbitrary program and input. This is an incredibly strong statement because it entails that a single counterexample is sufficient for proving the decidability of the halting problem. How do we go about this proof? The most straightforward way, used by Turing and others, is a <b>proof by contradiction</b>.</section>

<section>This proof technique might be foreign to you, but it's widely used in philosophy, mathematics, and computer science to prove numerous results. The general structure of the argument is:</section>
<section><b>1.</b> Assume that the <b>negation</b> of what we want to prove is true</section>
<section><b>2.</b> Use this assumption to infer a contradiction</section>
<section><b>3.</b> Use the contradiction to reject our assumption</section>

<section>We begin with our assumption that the halting problem is decidable.</section>
<section><b>Assumption:</b> The halting problem is decidable.</section>

<section>If the halting problem is decidable, then there exists a decider Turing machine that carries out the algorithm for all possible inputs. Let's refer to this decider algorithm for the halting problem as the <b>halting oracle M</b>. The internals of this halting oracle can't be described, since it in fact can't exist, but we are still assuming our function works as it should for every possible input. It makes sense then to consider this halting oracle as a black box that takes in a program and returns 'True' if the program halts, and 'False' otherwise.
</section>

<div class="img-wrapper">
	<img src="images/TM_program1.png"/>
</div>

<section>Let's also describe the halting algorithm with a simple Python function. This function will behave the exact same way as the halting oracle M above. Imagine we have something like the following:</section>

<code>
<p>def halt(w):</p>
<p class="indent-1">''' Return True if w halts, False if w does not halt '''</p>
<br/>
<p>halt(w)</p>
</code>

<section>Imagine that this function will work for any possible program passed to it, and that it will correctly determine whether or not the program will halt. To show that this algorithm can't exist, we need to build a <b>contrarian algorithm M'</b>, that responds to the output of our halting oracle and does the exact opposite.</section> 

<div class="img-wrapper">
	<img src="images/modded_TM.png"/>
</div>

<section>This typically wouldn't be an issue, but we are able to hack the contrarian machine into a contradiction, by passing the machine M' as an input into itself (i.e. we pass M' in as w).</section>

<section>If we visualize it in code, we can see the contradiction more explicitly.</section>

<code>
<p>def M_prime(M_prime):</p>
<p class="indent-1">if halt(w):</p>
<p class="indent-2">while True: continue</p>
<p class="indent-1">print("Halting")</p>
<br/>
<p>M_prime(M_prime)</p>
</code>

<section>If our halting function M determines that our contrarian function M' will halt, the contrarian function begins executing an infinite loop, thus not halting. If the halting function returns false, the contrarian function will print a statement and terminate, halting the program. So if M' is determined to halt, then it doesn't halt, and if it's determined not to halt, then it halts. Doesn't seem very sound, does it? This program can't be both true and false on the same input, so in order to avoid dealing with the contradiction, we are allowed to negate our assumption, inferring that our reasoning about the halting problem must've been wrong. The reasonable solution is to deny this assumption and conclude that the halting problem is undecidable. Our logic looks roughly like this:</section>

<section>If the halting problem is decidable, then we can build an algorithm that will correctly predict whether any program will halt or not. Since we have shown that we cannot build such an algorithm (because of the contrarian program is an exception to this), then we can conclude that the halting problem must be undecidable.</section>
